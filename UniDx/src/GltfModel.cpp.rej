diff a/UniDx/src/GltfModel.cpp b/UniDx/src/GltfModel.cpp	(rejected hunks)
@@ -18,6 +18,22 @@ static const Matrix4x4 xFlipMtx = Matrix4x4(
     0.f, 0.f, 1.f, 0.f,
     0.f, 0.f, 0.f, 1.f
 );
+const unsigned char* getAccessorData(const tinygltf::Model& model, const tinygltf::Accessor& accessor,
+    size_t& stride, size_t& count)
+{
+    if(accessor.bufferView < 0) return nullptr;
+    const auto& bufferView = model.bufferViews[accessor.bufferView];
+    const auto& buffer = model.buffers[bufferView.buffer];
+    size_t offset = bufferView.byteOffset + accessor.byteOffset;
+
+    count = accessor.count;
+    stride = bufferView.byteStride;
+    if(stride == 0)
+    {
+        stride = accessor.ByteStride(bufferView);
+    }
+    return buffer.data.data() + offset;
+}
 
 // tinygltf::Accessor から std::span<T> でデータを取得するヘルパー
 template<typename T>
@@ -196,113 +193,12 @@ bool GltfModel::load_(const char* filePath, bool makeTextureMaterial, std::share
 
     // Meshの生成
     meshes.clear();
-
     for (const auto& gltfMesh : model->meshes)
     {
         auto mesh = make_shared<Mesh>();
         for (const auto& primitive : gltfMesh.primitives)
         {
-            auto sub = make_shared<SkinnedSubMesh>();
-
-            // POSITION
-            if (auto it = primitive.attributes.find("POSITION"); it != primitive.attributes.end()) {
-                const auto& accessor = model->accessors[it->second];
-                sub->resizePositions(accessor.count);
-                ReadAccessorData(*model, accessor, true, sub->positionsData);
-            }
-
-            // NORMAL
-            if (auto it = primitive.attributes.find("NORMAL"); it != primitive.attributes.end()) {
-                const auto& accessor = model->accessors[it->second];
-                sub->resizeNormals(accessor.count);
-                ReadAccessorData(*model, accessor, true, sub->normalsData);
-            }
-            // TANGENT glTF: xyz=tangent, w=bitangent sign
-            if(auto it = primitive.attributes.find("TANGENT"); it != primitive.attributes.end()) {
-                const auto& accessor = model->accessors[it->second];
-                sub->tangentsData.resize(accessor.count);
-                ReadAccessorData(*model, accessor, true, sub->tangentsData);
-            }
-
-            // COLOR_0
-            if (auto it = primitive.attributes.find("COLOR_0"); it != primitive.attributes.end()) {
-                const auto& accessor = model->accessors[it->second];
-                sub->resizeColors(accessor.count);
-                ReadAccessorData(*model, accessor, false, sub->colorsData);
-            }
-
-            // TEXCOORD_0
-            if (auto it = primitive.attributes.find("TEXCOORD_0"); it != primitive.attributes.end()) {
-                const auto& accessor = model->accessors[it->second];
-                sub->resizeUV(accessor.count);
-                ReadAccessorData(*model, accessor, false, sub->uvData);
-            }
-            // TEXCOORD_1
-            if (auto it = primitive.attributes.find("TEXCOORD_1"); it != primitive.attributes.end()) {
-                const auto& accessor = model->accessors[it->second];
-                sub->resizeUV2(accessor.count);
-                ReadAccessorData(*model, accessor, false, sub->uv2Data);
-            }
-            // TEXCOORD_2
-            if (auto it = primitive.attributes.find("TEXCOORD_2"); it != primitive.attributes.end()) {
-                const auto& accessor = model->accessors[it->second];
-                sub->resizeUV3(accessor.count);
-                ReadAccessorData(*model, accessor, false, sub->uv3Data);
-            }
-            // TEXCOORD_3
-            if (auto it = primitive.attributes.find("TEXCOORD_3"); it != primitive.attributes.end()) {
-                const auto& accessor = model->accessors[it->second];
-                sub->resizeUV4(accessor.count);
-                ReadAccessorData(*model, accessor, false, sub->uv4Data);
-            }
-
-            // JOINTS_0 / WEIGHTS_0 (skinning)
-            if(auto it = primitive.attributes.find("JOINTS_0"); it != primitive.attributes.end()) {
-                const auto& accessor = model->accessors[it->second];
-                ReadAccessorU8x4(*model, accessor, sub->jointsData, /*isWeights*/false);
-            }
-            if(auto it = primitive.attributes.find("WEIGHTS_0"); it != primitive.attributes.end()) {
-                const auto& accessor = model->accessors[it->second];
-                ReadAccessorU8x4(*model, accessor, sub->weightsData, /*isWeights*/true);
-            }
-
-            // indices
-            if (primitive.indices >= 0) {
-                const auto& accessor = model->accessors[primitive.indices];
-                sub->resizeIndices(accessor.count);
-                auto& indices = sub->indicesData;
-
-                const auto& bufferView = model->bufferViews[accessor.bufferView];
-                const auto& buffer = model->buffers[bufferView.buffer];
-                size_t offset = bufferView.byteOffset + accessor.byteOffset;
-                const unsigned char* data = buffer.data.data() + offset;
-
-                if (accessor.componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_INT) {
-                    // 32bit index
-                    memcpy(indices.data(), data, accessor.count * sizeof(uint32_t));
-                }
-                else if (accessor.componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT) {
-                    // 16bit index → 32bitへ変換
-                    for (size_t i = 0; i < accessor.count; ++i) {
-                        indices[i] = reinterpret_cast<const uint16_t*>(data)[i];
-                    }
-                }
-                else if (accessor.componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE) {
-                    // 8bit index → 32bitへ変換
-                    for (size_t i = 0; i < accessor.count; ++i) {
-                        indices[i] = data[i];
-                    }
-                }
-
-                for(size_t i = 0; i + 2 < accessor.count; i += 3)
-                {
-                    // 座標系の反転で表裏が変わるので、インデクスを入れ替え
-                    std::swap(indices[i + 1], indices[i + 2]);
-                }
-            }
-
-            sub->topology = D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
-            mesh->submesh.push_back(sub);
+            readPrimitive(mesh.get(), primitive);
         }
         meshes.push_back(mesh);
     }
@@ -374,7 +269,7 @@ bool GltfModel::load_(const char* filePath, bool makeTextureMaterial, std::share
                 const uint8_t* p = base + i * stride;
                 Matrix4x4 localRH;
 
-                // glTFは列優先行列で最初が１列、UniDxは行優先行列で最初が１行なので、結果的に順番コピーでOK
+                // glTFは列ベクトルで最初の列から、UniDxは行ベクトルで最初の行からなので、結果的に順番コピーでOK
                 std::memcpy(&localRH, p, sizeof(float) * 16);
 
                 pair.second.inverseBind[i] = xFlipMtx * localRH * xFlipMtx;
